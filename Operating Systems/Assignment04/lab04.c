/*
    Written by: Chad Palmer
    CS-4328: Operating Systems
    Lab 4: LRU vs Optimal page replacement algorithms
    
    This program generates a reference String array and populates it with integer values 1-5
    at random and a page array with the size determined by the user.  It then passes the two
    arrays through the LRU and Optimal algorithms to determine the number of hits and misses
    generated by both.  Finally, the results are compared by calculating the hit to miss
    ratio and the efficiency improvement of the Optimal algorithm over LRU.
*/

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <stdbool.h>
#define REFSIZE 20

// PROTOTYPES
int* lru(int ref[], int page[], int refSize, int pages);
int* opt(int ref[], int page[], int refSize, int pages);
void printArray(const int arr[], int length);
int findOptimal(int pg[], int rf[], int pgSize, int curr);
bool scanPages(int ref, int pg[], int len);

int main() {
    
    srand(time(0));

    // Variables
    int  i, PAGESIZE;
    int* lruResults; 
    int* optResults;
    double hitRatio;

    // Reference String populated with integers 1-5 at random
    int referenceStr[REFSIZE];
    for (i = 0; i < REFSIZE; ++i) referenceStr[i] = (rand() % 5) + 1;

    // Prompt user for desired number of page frames
    printf("Enter number of pages: ");
    scanf("%d", &PAGESIZE);

    // Initialize page frame array elements with zeros
    int page[PAGESIZE];
    for (i = 0; i < PAGESIZE; ++i) { page[i] = 0; }

    // Display the reference string
    printf("\ncontents of referenceStr: ");
    printArray(referenceStr, REFSIZE);
    printf("\n\n");

    // Get LRU and Optimal results
    lruResults = lru(referenceStr, page, REFSIZE, PAGESIZE);
    optResults = opt(referenceStr, page, REFSIZE, PAGESIZE);

    // Analysis of LRU and Optimal results
    hitRatio = ((double)lruResults[0] / (double)optResults[0]);
    printf("lruResults:  Hit = %d, Miss = %d\n", lruResults[0], lruResults[1]);
    printf("optResults:  Hit = %d, Miss = %d\n", optResults[0], optResults[1]);

    // Compare LRU and Optimal efficiency with respect to hits/misses
    printf("LRU:Optimal hit ratio: %.2f\n", hitRatio);
    printf("Optimal ran %.2f percent more efficient than LRU.\n", (1.0 - hitRatio) * 100);
                                                                                            
    return 0;
}

int* lru(int ref[], int page[], int refSize, int pages) {
    static int results[2] = {0, 0};
    bool hit;
    int insert = 0;
    int i = 0;
    printf("=====LRU Algorithm=====\n");
    for (i = 0; i < refSize; ++i) {
        printf("pg: %d | ", ref[i]);
        printArray(page, pages);
        hit = scanPages(ref[i], page, pages);
        if (hit) {                                      // If there is a hit,
            printf("| HIT\n");                          // increment hit results
            ++results[0];
        }
            
        else {                                          // Otherwise, insert new reference
            printf("| MISS\n");                         // and increment miss results
            page[insert] = ref[i];
            ++results[1];                               // If page[] empty or has empty slots,
            if (insert < pages-1)                       // fill first available page frame
                insert++;
            else                                        // If page[] full, replace old
                insert = 0;                             // reference in FIFO order
        }
    }
    printf("----------------\n");
    printf("final page stack: ");
    printArray(page, pages);
    printf("\n\n");

    for (i = 0; i < pages; ++i) { page[i] = 0; }        // Reset page array
    return results;
}

int* opt(int ref[], int page[], int refSize, int pages) {
    static int results[2] = {0, 0};
    int insert = 0;
    int i = 0;
    bool hit;
    bool full;
    printf("===Optimal Algorithm===\n");
    for (i = 0; i < refSize; ++i) {
        printf("pg: %d | ", ref[i]);
        printArray(page, pages);
        hit = scanPages(ref[i], page, pages);
        full = (page[pages-1] != 0);
        
        if (hit) {                                      // If there is a hit,
            printf("| HIT\n");                          // increment the hit results
            ++results[0];
        }
        else {                                          // Otherwise, insert new reference
            printf("| MISS\n");                         // and increment miss results
            if (full) {
                // Find optimal page to swap out
                insert = findOptimal(page, ref, pages, i);  // To swap references, find optimal
                page[insert] = ref[i];                      // reference first (next reference
            }                                               // furthest in the future)
            else {                                      
                // empty page exists, fill it           // If page[] empty or has empty slots,
                page[insert] = ref[i];                  // fill first availabe page frame
                ++insert;
            }
            ++results[1];
        }
    }
    printf("----------------\n");
    printf("final page stack: ");
    printArray(page, pages);
    printf("\n\n");
    for (i = 0; i < pages; ++i) { page[i] = 0; }
    return results;
}

void printArray(const int arr[], int length) {
    int i = 0;
    for (i = 0; i < length; ++i)
        printf("%d  ", arr[i]);
}

int findOptimal(int pg[], int rf[], int pgSize, int curr) {
    int i, j, opt, optAddress, stepCount;
    int steps[pgSize];                                  // curr points to first of remaining ref
    for (i = 0; i < pgSize; ++i) { steps[i] = -1; }     // Initialize steps array elements with -1

    for (i = 0; i < pgSize; ++i) {                      // steps[] elements populated with # of steps
        stepCount = 0;                                  // it takes to find matching page reference
        for (j = curr; j < REFSIZE; ++j) {              
            if ( (pg[i] == rf[j]) && (stepCount < REFSIZE) ) {
                steps[i] = stepCount;
                stepCount = REFSIZE + 1; 
            }
            else { ++stepCount; }            
        }
    }

    opt = steps[0];
    optAddress = 0;

    for (i = 0; i < pgSize; ++i) {                      // a -1 in steps[] indicates that a current value in
        if (steps[i] == -1)                             // page will not be called again. return this address
            return i;
        else {                                          // otherwise, return the page value furthest away.
            if (opt < steps[i]) {
                opt = steps[i];
                optAddress = i;
            }
        }
    }
    return optAddress;
}

bool scanPages(int ref, int pg[], int len) {
    int i = 0;
    for (i = 0; i < len; ++i) {
        if (ref == pg[i])
            return true;
    }
    return false;
}